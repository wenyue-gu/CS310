# RAFT

This is an updated version of the Raft lab, created by the AG350 team.  The new structure enables deterministic testing with more
granular control.   In a test scenario, each Raft replica
runs as a RaftNode object.  To complete the lab, complete the Raft protocol implementation in RaftNode.java.

In the old Raft lab, separate processes are spun up
for each server when tests are run. In tests, these processes are
killed and started up at different times. The testers do not have
control over the replica timers, and have
less control over which network requests are successful.

This new version of the Raft lab is based on dependency injection, and simulates
a multi-server environment. Network traffic is fake/simulated, and everything runs
in a single-threaded process. Testers inject objects and events into each RaftNode,
which the RaftNode implementation reacts to. Testers can then
view the state of these objects at any point in testing.

Each test scenario calls the RaftNode constructor to instantiate a RaftNode object for
each replica in the scenario, as in the supplied test programs.
All replica objects run with the test program in a
single-threaded process.  The test harness starts the RaftNode replicas in any
mode of its choosing according to the scenario.

A RaftNode must implement handler methods for three kinds of input events: RequestVotes requests from other replicas acting as candidate,
AppendEntry requests from other replicas acting as leader, and timeouts from an internal timer.
These inputs are generated by the test harness.
How RaftNode handles these inputs depends on its RaftNode's current mode, which specifies
whether the replica is acting
as a candidate, follower, or leader.
The test harness interrogates the RaftNode.get* methods to
check that the replicas function correctly, so RaftNode must implement those as well.

The replicas communicate through the test harness, which
simulates network communication and simulates failures by selectively blocking messages.
A RaftNode in leader mode or candidate mode uses its 
AppendEntryRequester and VoteRequester objects to send RPCs and retrieve the responses.  Each Requester object has a
method to send an RPC of its type to a specific receiver, and methods to retrieve or query received responses for RPCs
that were sent during a specified term.  Leaders and candidates implement group message rounds by sending an RPC to each of its peers, waiting for one timeout, and then calling the Requester object to check (poll) the responses
